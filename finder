local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

local towerFolder = workspace:WaitForChild("Tower")
local MAX_DISTANCE = 200 -- studs

-- Get player HRP
local function getHRP()
    local character = player.Character or player.CharacterAdded:Wait()
    return character:WaitForChild("HumanoidRootPart")
end

local hrp = getHRP()

-- CHEST COLOR â†’ NAME TABLE
local ChestTypes = {
    ["Really black"] = "CursedChest",
    ["Dark stone grey"] = "CommonChest",
    ["Mulberry"] = "EpicChest",
    ["CGA brown"] = "LegendaryChest",
    ["Maroon"] = "MythicChest",
    ["Dark Royal blue"] = "RareChest",
    ["Earth green"] = "UncommonChest",
}

local RUBY_COLOR = Color3.fromRGB(255, 0, 0)

-- All tracked ESPs
local chestMap = {}

-- Create fancy ESP (works on any BasePart / MeshPart)
local function createESP(adornee)
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ChestESP"
    billboard.Adornee = adornee
    billboard.Size = UDim2.new(0, 160, 0, 60)
    billboard.StudsOffset = Vector3.new(0, 4, 0)
    billboard.AlwaysOnTop = true
    billboard.Enabled = true

    local bg = Instance.new("Frame")
    bg.Parent = billboard
    bg.Size = UDim2.new(1,0,1,0)
    bg.BackgroundColor3 = Color3.new(0,0,0)
    bg.BackgroundTransparency = 0.3

    local stroke = Instance.new("UIStroke")
    stroke.Parent = bg
    stroke.Thickness = 2
    stroke.Color = Color3.new(1,1,1)

    Instance.new("UICorner", bg)

    local label = Instance.new("TextLabel")
    label.Parent = bg
    label.Size = UDim2.new(1,-6,1,-6)
    label.Position = UDim2.new(0,3,0,3)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.new(1,1,1)
    label.Font = Enum.Font.FredokaOne
    label.TextScaled = true
    label.TextStrokeTransparency = 0.3
    label.TextStrokeColor3 = Color3.new(0,0,0)

    billboard.Parent = adornee
    return billboard, label, stroke
end

-- Register new chest (Model with PrimaryPart + Down + ProximityPrompt)
local function registerChest(chest)
    if chestMap[chest] then return end
    if not chest:IsA("Model") or not chest.PrimaryPart then return end

    local down = chest:FindFirstChild("Down")
    if not (down and down:IsA("BasePart")) then return end

    local prompt = chest:FindFirstChildOfClass("ProximityPrompt")
    if not prompt then return end

    -- Get BrickColor name â†’ chest type
    local bcName = down.BrickColor.Name
    local chestType = ChestTypes[bcName] or "UnknownChest"

    local espGui, espLabel, stroke = createESP(chest.PrimaryPart)

    chestMap[chest] = {
        model = chest,
        primary = chest.PrimaryPart,
        down = down,
        espGui = espGui,
        espLabel = espLabel,
        outline = stroke,
        chestType = chestType,
        -- requirePrompt = nil / true (default) â†’ still needs ProximityPrompt
    }
end

-- Register Ruby MeshPart (can be anywhere under Tower["X"])
local function registerRuby(ruby)
    if chestMap[ruby] then return end
    if not ruby:IsA("MeshPart") then return end

    local espGui, espLabel, stroke = createESP(ruby)

    chestMap[ruby] = {
        model = ruby,
        primary = ruby,
        down = nil,
        espGui = espGui,
        espLabel = espLabel,
        outline = stroke,
        chestType = "Ruby",
        requirePrompt = false,    -- Ruby doesn't need a ProximityPrompt
        colorResolver = function()
            return RUBY_COLOR
        end,
    }
end

local function findExpBookDesc(expBook)
    local right = expBook:FindFirstChild("Right")
    if not right then return nil end

    local surfaceGui = right:FindFirstChildOfClass("SurfaceGui") or right:FindFirstChild("SurfaceGui")
    if not surfaceGui then return nil end

    local expFrame = surfaceGui:FindFirstChild("EXP")
    if not expFrame then return nil end

    return expFrame:FindFirstChild("Desc")
end

local function readDescTextColor(desc)
    if not desc then return nil end

    local attrColor = desc:GetAttribute("TextColor3")
    if typeof(attrColor) == "Color3" then
        return attrColor
    end

    local ok, textColor = pcall(function()
        return desc.TextColor3
    end)

    if ok and typeof(textColor) == "Color3" then
        return textColor
    end

    return nil
end

local function readDescTextValue(desc)
    if not desc then return nil end

    local attrText = desc:GetAttribute("Text")
    if typeof(attrText) == "string" and attrText ~= "" then
        return attrText
    end

    local ok, textValue = pcall(function()
        return desc.Text
    end)

    if ok and typeof(textValue) == "string" and textValue ~= "" then
        return textValue
    end

    return nil
end

local function parseColorString(str)
    if type(str) ~= "string" then return nil end

    local numbers = {}
    for token in string.gmatch(str, "[%-%d%.]+") do
        local num = tonumber(token)
        if num then
            table.insert(numbers, num)
        end
    end

    if #numbers < 3 then
        return nil
    end

    local startIndex = 1
    if #numbers >= 4 then
        if (#numbers % 4 == 0) or (#numbers % 5 == 0) then
            startIndex = 2
        end
    end

    local r = math.clamp(numbers[startIndex] or 0, 0, 1)
    local g = math.clamp(numbers[startIndex + 1] or r, 0, 1)
    local b = math.clamp(numbers[startIndex + 2] or g, 0, 1)
    return Color3.new(r, g, b)
end

local function colorFromAttribute(value)
    local valueType = typeof(value)
    if valueType == "Color3" then
        return value
    elseif valueType == "ColorSequence" then
        return value:Evaluate(0.5)
    elseif valueType == "BrickColor" then
        return value.Color
    elseif valueType == "Vector3" then
        return Color3.new(
            math.clamp(value.X, 0, 1),
            math.clamp(value.Y, 0, 1),
            math.clamp(value.Z, 0, 1)
        )
    elseif valueType == "table" then
        local r = value.R or value.r or value[1]
        local g = value.G or value.g or value[2]
        local b = value.B or value.b or value[3]
        if typeof(r) == "number" and typeof(g) == "number" and typeof(b) == "number" then
            return Color3.new(
                math.clamp(r, 0, 1),
                math.clamp(g, 0, 1),
                math.clamp(b, 0, 1)
            )
        end
    elseif valueType == "string" then
        return parseColorString(value)
    end

    return nil
end

local function readInstanceColor(source)
    if not source or not source.Parent then
        return nil
    end

    local attrValue = source:GetAttribute("AppearanceColor") or source:GetAttribute("Color")
    local attrColor = attrValue and colorFromAttribute(attrValue)
    if attrColor then
        return attrColor
    end

    if source:IsA("ParticleEmitter") then
        local ok, seq = pcall(function()
            return source.Color
        end)

        if ok and typeof(seq) == "ColorSequence" then
            return seq:Evaluate(0.5)
        end
    elseif source:IsA("BasePart") then
        return source.Color
    end

    return nil
end

local function registerBagOfGold(node)
    if not (node:IsA("Model") or node:IsA("BasePart") or node:IsA("ParticleEmitter")) then return end

    local bagRoot
    local highlightPart
    local function resolveBagModel(instance)
        if instance:IsA("Model") then
            return instance
        end
        return instance:FindFirstAncestorWhichIsA("Model")
    end

    bagRoot = resolveBagModel(node)
    if not bagRoot then return end

    if chestMap[bagRoot] then return end

    if node:IsA("BasePart") then
        highlightPart = node
    else
        highlightPart = bagRoot.PrimaryPart or bagRoot:FindFirstChildWhichIsA("BasePart")
    end

    if not (highlightPart and highlightPart:IsA("BasePart")) then
        return
    end

    local espGui, espLabel, stroke = createESP(highlightPart)

    local function resolveBagColor()
        if not (bagRoot and bagRoot.Parent) then
            return highlightPart and highlightPart.Color or Color3.new(1, 1, 0)
        end

        local candidates = {}
        local function addCandidate(inst)
            if inst then
                table.insert(candidates, inst)
            end
        end

        addCandidate(bagRoot:FindFirstChild("Rays"))

        local bagChildren = bagRoot:GetChildren()
        if bagChildren[4] then
            addCandidate(bagChildren[4])
        end

        for _, child in ipairs(bagChildren) do
            if child:IsA("ParticleEmitter") then
                addCandidate(child)
            end
        end

        addCandidate(highlightPart)

        for _, source in ipairs(candidates) do
            local color = readInstanceColor(source)
            if color then
                return color
            end
        end

        return highlightPart.Color
    end

    chestMap[bagRoot] = {
        model = bagRoot,
        primary = highlightPart,
        down = nil,
        espGui = espGui,
        espLabel = espLabel,
        outline = stroke,
        chestType = "BagOfGold",
        requirePrompt = false,
        colorResolver = resolveBagColor,
    }
end

-- Register EXPBook (Model with a BasePart child)
local function registerEXPBook(expBook)
    if chestMap[expBook] then return end
    if not (expBook:IsA("BasePart") or expBook:IsA("Model")) then return end

    local highlightPart
    if expBook:IsA("BasePart") then
        highlightPart = expBook
    else
        highlightPart = expBook.PrimaryPart or expBook:FindFirstChildWhichIsA("BasePart")
    end

    if not highlightPart then return end

    local espGui, espLabel, stroke = createESP(highlightPart)
    local descRef = findExpBookDesc(expBook)

    local function resolveExpColor()
        if not descRef or not descRef.Parent then
            descRef = findExpBookDesc(expBook)
        end

        return readDescTextColor(descRef) or highlightPart.Color
    end

    local function resolveExpLabel()
        if not descRef or not descRef.Parent then
            descRef = findExpBookDesc(expBook)
        end

        local descText = readDescTextValue(descRef)
        if descText and descText ~= "" then
            return string.format("EXPBook - %s", descText)
        end

        return "EXPBook"
    end

    chestMap[expBook] = {
        model = expBook,
        primary = highlightPart,
        down = highlightPart,     -- still track the part for cleanup
        espGui = espGui,
        espLabel = espLabel,
        outline = stroke,
        chestType = "EXPBook",
        requirePrompt = false,    -- EXPBook doesn't need a ProximityPrompt
        colorResolver = resolveExpColor,
        labelResolver = resolveExpLabel,
    }
end

-- Validate & load tower
local function scanTower(tower)
    if not tonumber(tower.Name) then return end

    -- Normal chest
    local chest = tower:FindFirstChild("Chest")
    if chest then
        registerChest(chest)
    end

    -- Ruby (e.g. workspace.Tower["X"].Ruby)
    local ruby = tower:FindFirstChild("Ruby")
    if ruby then
        registerRuby(ruby)
    end

    -- EXPBook (e.g. workspace.Tower["2"].EXPBook)
    local expBook = tower:FindFirstChild("EXPBook")
    if expBook then
        registerEXPBook(expBook)
    end

    -- Bag of Gold (e.g. workspace.Tower["N"].Bags.GoldBag.Rays)
    local bagsFolder = tower:FindFirstChild("Bags")
    if bagsFolder then
        for _, bag in ipairs(bagsFolder:GetChildren()) do
            if bag.Name == "GoldBag" then
                registerBagOfGold(bag)
            end
        end
    end
end

-- MAIN UPDATE LOOP
RunService.RenderStepped:Connect(function()
    if not hrp or not hrp.Parent then
        hrp = getHRP()
    end

    -- ðŸ”„ Rescan towers every frame (your original behavior)
    for _, tower in ipairs(towerFolder:GetChildren()) do
        scanTower(tower)
    end

    -- Update or remove ESP
    for chest, data in pairs(chestMap) do
        local model = data.model

        if not model or not model.Parent then
            if data.espGui then
                data.espGui:Destroy()
            end
            chestMap[chest] = nil
            continue
        end

        -- For normal chests we still require a ProximityPrompt; Ruby/EXPBook can skip it
        if data.requirePrompt ~= false and not model:FindFirstChildOfClass("ProximityPrompt") then
            if data.espGui then
                data.espGui:Destroy()
            end
            chestMap[chest] = nil
            continue
        end

        -- Refresh down part color â†’ chest type / color
        local color
        if data.colorResolver then
            local ok, resolved = pcall(data.colorResolver)
            if ok and typeof(resolved) == "Color3" then
                color = resolved
            end
        end

        local down = data.down
        if down and down.Parent then
            local bcName = down.BrickColor.Name

            -- Only override chestType if it's a known chest color
            if ChestTypes[bcName] then
                data.chestType = ChestTypes[bcName]
            end

            -- Color outline and text with part color
            color = color or down.Color
        end

        if color then
            data.espLabel.TextColor3 = color
            data.outline.Color = color
        end

        -- Distance logic
        local primary = data.primary
        if primary and primary.Parent and hrp then
            local dist = (primary.Position - hrp.Position).Magnitude
            local inRange = dist <= MAX_DISTANCE
            data.espGui.Enabled = inRange

            if inRange then
                local labelPrefix = data.chestType
                if data.labelResolver then
                    local okText, resolvedText = pcall(data.labelResolver)
                    if okText and type(resolvedText) == "string" and resolvedText ~= "" then
                        labelPrefix = resolvedText
                    end
                end

                data.espLabel.Text = string.format("%s\n%d studs", labelPrefix, dist)
            end
        else
            -- If primary part disappears, hide ESP
            data.espGui.Enabled = false
        end
    end
end)
