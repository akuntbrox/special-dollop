-- V2 of the auto medal helper: same overall flow but with sturdier equip/aura handling and lobby enemy monitoring.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Debris = game:GetService("Debris")
local TeleportService = game:GetService("TeleportService")

local DEFAULT_LOBBY_PLACE_ID = 80620565999570
local ARENA_PLACE_ID = 136994634055993
local TELEPORT_PLACE_ID = DEFAULT_LOBBY_PLACE_ID
local TELEPORT_LINK_SOURCE_URL = "https://raw.githubusercontent.com/akuntbrox/special-dollop/refs/heads/main/jobId"
local AUTO_TELEPORT_JOB_ID = ""
local SETTINGS_SEQUENCE = {"Private", "Map"}
local TARGET_PLAYER_NAMES = {"Cetinowalliw54"}
local TARGET_PLAYER_SET = {}
for _, target in ipairs(TARGET_PLAYER_NAMES) do
    TARGET_PLAYER_SET[target] = true
end
local ENEMY_CHECK_INTERVAL = 3
local CRITICAL_CHILD_TIMEOUT = 12
local REJOIN_DELAY = 5
local MAX_REJOIN_ATTEMPTS = 3

if not game:IsLoaded() then
    game.Loaded:Wait()
end

local LocalPlayer = Players.LocalPlayer or Players.PlayerAdded:Wait()

local rejoinInProgress = false
local rejoinAttempts = 0

local function scheduleRejoin(reason)
    if rejoinInProgress then
        return
    end
    rejoinInProgress = true
    rejoinAttempts += 1
    warn(string.format("[AutoPrivateLobby] Scheduling rejoin (%s). Attempt %d.", tostring(reason or "unknown"), rejoinAttempts))

    task.spawn(function()
        task.wait(REJOIN_DELAY)
        local ok, err = pcall(function()
            TeleportService:Teleport(TELEPORT_PLACE_ID, LocalPlayer)
        end)
        if not ok then
            warn(string.format("[AutoPrivateLobby] Failed to rejoin automatically: %s", tostring(err)))
            rejoinInProgress = false
            if rejoinAttempts < MAX_REJOIN_ATTEMPTS then
                scheduleRejoin(reason)
            end
        end
    end)
end

local function waitForChildCritical(parent, childName, timeout, reasonTag)
    if not parent then
        scheduleRejoin(reasonTag or ("MissingParent:" .. tostring(childName)))
        return nil
    end
    local deadline = os.clock() + (timeout or CRITICAL_CHILD_TIMEOUT)
    local child = parent:FindFirstChild(childName)
    while not child and os.clock() < deadline do
        local ok, result = pcall(function()
            return parent:WaitForChild(childName, 1)
        end)
        if ok and result then
            child = result
            break
        end
    end
    if not child then
        warn(string.format("[AutoPrivateLobby] Critical instance '%s' missing under %s. Rejoining.", tostring(childName), parent.Name))
        scheduleRejoin(reasonTag or ("MissingChild:" .. tostring(childName)))
    end
    return child
end

local playerReady = false

local function waitForPlayerReady()
    if playerReady then
        return
    end

    local character = LocalPlayer.Character
    if not character or not character.Parent then
        local ok, result = pcall(function()
            return LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        end)
        if ok then
            character = result
        end
    end

    if character then
        pcall(function()
            character:WaitForChild("Humanoid", 10)
        end)
        pcall(function()
            character:WaitForChild("HumanoidRootPart", 10)
        end)
    end

    local playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
    if not playerGui then
        local ok, result = pcall(function()
            return LocalPlayer:WaitForChild("PlayerGui", 10)
        end)
        if ok then
            playerGui = result
        end
    end

    if playerGui then
        pcall(function()
            playerGui:WaitForChild("ScreenInfo", 10)
        end)

        local hotbar = playerGui:FindFirstChild("HotBar")
        if not hotbar then
            local ok, result = pcall(function()
                return playerGui:WaitForChild("HotBar", 10)
            end)
            if ok then
                hotbar = result
            end
        end

        if hotbar then
            local infoFrame = hotbar:FindFirstChild("Info")
            if not infoFrame then
                local ok, result = pcall(function()
                    return hotbar:WaitForChild("Info", 10)
                end)
                if ok then
                    infoFrame = result
                end
            end

            if infoFrame and infoFrame:IsA("GuiObject") then
                if not infoFrame.Visible then
                    local startTime = os.clock()
                    while not infoFrame.Visible and os.clock() - startTime < 60 do
                        local ok = pcall(function()
                            infoFrame:GetPropertyChangedSignal("Visible"):Wait()
                        end)
                        if not ok then
                            break
                        end
                    end
                end

                if not infoFrame.Visible then
                    warn("[AutoPrivateLobby] HotBar.Info never became visible; continuing anyway.")
                end
            end
        end
    end

    playerReady = true
end

local function parseTeleportLink(raw)
    if typeof(raw) ~= "string" then
        return nil, nil
    end

    local placeId = raw:match("placeId=(%d+)")
    if not placeId then
        placeId = raw:match("placeid=(%d+)")
    end

    local jobId = raw:match("gameInstanceId=([%w%-]+)")
    if not jobId then
        jobId = raw:match("jobId=([%w%-]+)") or raw:match("instanceId=([%w%-]+)")
    end

    return tonumber(placeId), jobId
end

local function fetchRemoteTeleportTarget()
    if TELEPORT_LINK_SOURCE_URL == "" then
        return nil, nil
    end

    local ok, response = pcall(function()
        return game:HttpGet(TELEPORT_LINK_SOURCE_URL)
    end)

    if not ok then
        warn(string.format("[AutoPrivateLobby] Failed to fetch teleport link: %s", tostring(response)))
        return nil, nil
    end

    local placeId, jobId = parseTeleportLink(response)
    if not jobId or jobId == "" then
        warn(string.format("[AutoPrivateLobby] Teleport link missing JobId: %s", tostring(response)))
        return nil, nil
    end

    return placeId, jobId
end

local function sanitizeJobId(jobId)
    if typeof(jobId) ~= "string" then
        jobId = tostring(jobId or "")
    end

    jobId = jobId:gsub("%s+", "")
    if jobId == "" then
        return nil
    end

    return jobId
end

local function teleportToJobId(jobId, contextLabel, overridePlaceId)
    local targetPlaceId = overridePlaceId or TELEPORT_PLACE_ID or game.PlaceId
    if typeof(targetPlaceId) ~= "number" then
        targetPlaceId = tonumber(targetPlaceId) or DEFAULT_LOBBY_PLACE_ID
    end

    local trimmed = sanitizeJobId(jobId)
    if not trimmed then
        local remotePlaceId, remoteJobId = fetchRemoteTeleportTarget()
        trimmed = sanitizeJobId(remoteJobId) or sanitizeJobId(AUTO_TELEPORT_JOB_ID)
        if remotePlaceId then
            targetPlaceId = remotePlaceId
        end
    end

    if not trimmed then
        warn(string.format("[AutoPrivateLobby] No JobId available%s; teleport aborted.", contextLabel and (" (" .. contextLabel .. ")") or ""))
        return false
    end

    local currentJobId = sanitizeJobId(game.JobId)
    if currentJobId and currentJobId == trimmed then
        print("[AutoPrivateLobby] Current server already matches teleport target; skipping teleport.")
        return false
    end

    local ok, err = pcall(function()
        TeleportService:TeleportToPlaceInstance(targetPlaceId, trimmed, LocalPlayer)
    end)

    if not ok then
        warn(string.format("[AutoPrivateLobby] Teleport failed%s: %s", contextLabel and (" (" .. contextLabel .. ")") or "", tostring(err)))
        return false
    end

    print(string.format("[AutoPrivateLobby] Teleporting to JobId %s (Place %s)", trimmed, tostring(targetPlaceId)))
    return true
end

_G = _G or {}
_G.AutoMedalTeleportToJobId = teleportToJobId

do
    local autoJob = sanitizeJobId(AUTO_TELEPORT_JOB_ID)
    if game.PlaceId == ARENA_PLACE_ID then
        print("[AutoPrivateLobby] Arena place detected at startup; skipping auto lobby teleport.")
    elseif autoJob or TELEPORT_LINK_SOURCE_URL ~= "" then
        teleportToJobId(autoJob, "AutoStart")
    end
end
local function bootstrapArenaModule()
    print("[AutoPrivateLobby] Bootstrap disabled; no events fired on load.")
end
bootstrapArenaModule()

local function startAutoPrivateLobby()
    local USE_SAME_EQUIPMENT = false

    local function resolveTargetPlayer(targetName)
        local player = Players:FindFirstChild(targetName)
        if player then
            return player
        end
        local ok, result = pcall(function()
            return Players:WaitForChild(targetName, 5)
        end)
        if ok then
            return result
        end
        return nil
    end

    task.spawn(function()
        task.wait(24)
        local eventsFolder = waitForChildCritical(ReplicatedStorage, "Events", 10, "SimpleLobbyEvents")
        if not eventsFolder then
            return
        end

        local createGroupEvent = waitForChildCritical(eventsFolder, "CreateArenaGroup", 10, "SimpleCreateArenaGroup")
        local changeSettingEvent = waitForChildCritical(eventsFolder, "ArenaGroupChangeSetting", 10, "SimpleChangeSetting")
        local inviteEvent = waitForChildCritical(eventsFolder, "SendInvitePlayerToArenaGroup", 10, "SimpleInvite")
        local startArenaEvent = waitForChildCritical(eventsFolder, "StartArenaGroup", 10, "SimpleStartArena")

        if not createGroupEvent then
            return
        end

        local okCreate, errCreate = pcall(function()
            game:GetService("ReplicatedStorage"):FindFirstChild("Events"):FindFirstChild("CreateArenaGroup"):FireServer()
        end)

        if okCreate then
            print("[AutoPrivateLobby] Fired CreateArenaGroup after 24s delay.")
        else
            warn(string.format("[AutoPrivateLobby] Failed to fire CreateArenaGroup: %s", tostring(errCreate)))
            return
        end

        if changeSettingEvent then
            for _, setting in ipairs(SETTINGS_SEQUENCE) do
                local okSetting, errSetting = pcall(function()
                    changeSettingEvent:FireServer(setting)
                end)
                if not okSetting then
                    warn(string.format("[AutoPrivateLobby] Failed to apply '%s' setting: %s", tostring(setting), tostring(errSetting)))
                end
                task.wait(0.4)
            end
        end

        if inviteEvent then
            for _, targetName in ipairs(TARGET_PLAYER_NAMES) do
                local targetPlayer = resolveTargetPlayer(targetName)
                if not targetPlayer then
                    warn(string.format("[AutoPrivateLobby] Could not find %s to invite.", targetName))
                else
                    local okInvite, errInvite = pcall(function()
                        inviteEvent:InvokeServer(targetPlayer)
                    end)
                    if not okInvite then
                        warn(string.format("[AutoPrivateLobby] Failed to invite %s: %s", targetPlayer.Name, tostring(errInvite)))
                    end
                end
                task.wait(0.4)
            end
        end
        task.wait(2)
        if startArenaEvent then
            local okStart, errStart = pcall(function()
                startArenaEvent:FireServer(USE_SAME_EQUIPMENT)
            end)
            if okStart then
                print("[AutoPrivateLobby] StartArenaGroup invoked automatically.")
            else
                warn(string.format("[AutoPrivateLobby] Failed to start arena: %s", tostring(errStart)))
            end
        end
    end)
end

local function startAlmostAura()
    local EventsFolder = waitForChildCritical(ReplicatedStorage, "Events", 10, "AuraEventsMissing")
    local ModelsFolder = waitForChildCritical(ReplicatedStorage, "Models", 10, "AuraModelsMissing")
    if not (EventsFolder and ModelsFolder) then
        return
    end
    local ClientHitbox = waitForChildCritical(ModelsFolder, "ClientAroundHitbox", 10, "AuraClientHitboxMissing")
    local WeaponsEvent = waitForChildCritical(EventsFolder, "WeaponsEvent", 10, "AuraWeaponsEventMissing")
    local AttackEvent = waitForChildCritical(EventsFolder, "AttackV2", 10, "AuraAttackMissing")
    local VFXEvent = waitForChildCritical(EventsFolder, "VFX_Client", 10, "AuraVFXMissing")
    if not (ClientHitbox and WeaponsEvent and AttackEvent and VFXEvent) then
        return
    end

    local lastEquipTime = 0
    local equipInProgress = false
    local EQUIP_COOLDOWN = 1.5

    local function fireWeaponEquip()
        local now = os.clock()
        if equipInProgress then
            return true
        end
        if now - lastEquipTime < EQUIP_COOLDOWN then
            return true
        end
        equipInProgress = true
        local ok, err = pcall(function()
            WeaponsEvent:FireServer("Equip/UnEquip")
        end)
        equipInProgress = false
        if ok then
            lastEquipTime = now
        else
            warn(string.format("[AuraKill] Failed to prep weapon equip: %s", tostring(err)))
        end
        return ok
    end

    local AURA_RANGE = 150
    local AURA_INTERVAL = 0.02
    local MAX_COMBO_STAGE = 3
    local ATTACK_ATTR_TIMEOUT = 0.15

    local auraEnabled = false
    local comboStage = 0
    local nextPulseTime = 0
    local heartbeatConnection = nil

    local Character = nil
    local HumanoidRootPart = nil
    local auraContainer = nil
    local DEFAULT_DIRECTION = "0:0:-1"
    local attackingStateCount = 0
    local TARGET_PART_NAMES = {
        CharHitbox = true;
        CharHitBox = true;
    }

    local function setCharacter(char)
        Character = char
        HumanoidRootPart = nil
        attackingStateCount = 0
        if not Character then
            return
        end
        task.spawn(function()
            HumanoidRootPart = Character:WaitForChild("HumanoidRootPart", 5)
        end)
    end

    if LocalPlayer.Character then
        setCharacter(LocalPlayer.Character)
    end
    LocalPlayer.CharacterAdded:Connect(setCharacter)

    local function canAttack()
        if not Character or not Character.Parent then
            return false
        end
        if Character:GetAttribute("Stunned") then
            return false
        end
        if not Character:GetAttribute("IsEquipped") then
            return false
        end
        if Character:GetAttribute("IsDashing") or Character:GetAttribute("IsEquipping") or Character:GetAttribute("IsCrawling") then
            return false
        end
        if not HumanoidRootPart or not HumanoidRootPart.Parent then
            return false
        end
        return true
    end

    local function buildPayload(target)
        local id = target:GetAttribute("ID")
        if id then
            return {id}
        end
        return target
    end

    local function beginAttackingState()
        if not Character then
            return
        end
        attackingStateCount = attackingStateCount + 1
        Character:SetAttribute("Attacking", true)
    end

    local function endAttackingState()
        if not Character then
            attackingStateCount = 0
            return
        end
        if attackingStateCount > 0 then
            attackingStateCount = attackingStateCount - 1
        end
        if attackingStateCount <= 0 then
            attackingStateCount = 0
            Character:SetAttribute("Attacking", false)
        end
    end

    local function compressVector(vec)
        return string.format("%.2f:%.2f:%.2f", vec.X, vec.Y, vec.Z)
    end

    local PRIORITY_TARGET_PARTS = {"HumanoidRootPart", "CharHitbox", "CharHitBox"}

    local function getTargetPosition(target)
        if not target then
            return nil
        end
        if target:IsA("BasePart") then
            return target.Position
        end
        for _, partName in ipairs(PRIORITY_TARGET_PARTS) do
            local part = target:FindFirstChild(partName, true)
            if part and part:IsA("BasePart") then
                return part.Position
            end
        end
        local primary = target.PrimaryPart
        if primary then
            return primary.Position
        end
        if target:IsA("Model") then
            local success, pivot = pcall(function()
                return target:GetPivot()
            end)
            if success and pivot then
                return pivot.Position
            end
            local anyPart = target:FindFirstChildWhichIsA("BasePart", true)
            if anyPart then
                return anyPart.Position
            end
        end
        return nil
    end

    local function nextComboStage()
        comboStage = comboStage + 1
        if comboStage > MAX_COMBO_STAGE then
            comboStage = 1
        end
        return comboStage
    end

    local function getDirectionString(target)
        local base = nil
        if HumanoidRootPart then
            base = HumanoidRootPart.CFrame.LookVector
            if target then
                local targetPosition = getTargetPosition(target)
                if targetPosition then
                    local offset = targetPosition - HumanoidRootPart.Position
                    if offset.Magnitude > 0.01 then
                        base = offset.Unit
                    end
                end
            end
        end
        if not base then
            return DEFAULT_DIRECTION
        end
        return compressVector(base)
    end

    local function attackTarget(target)
        local stage = nextComboStage()
        local payload = buildPayload(target)
        local directionString = getDirectionString(target)
        beginAttackingState()
        AttackEvent:FireServer(1, stage)
        local directionArgs = {4, stage}
        directionArgs[4] = directionString
        AttackEvent:FireServer(table.unpack(directionArgs))
        AttackEvent:FireServer(5, stage, payload)
        if Character and Character:GetAttribute("Subclass") == "Assassin" and stage == MAX_COMBO_STAGE then
            AttackEvent:FireServer(5, stage, payload)
        end
        AttackEvent:FireServer(3, stage)
        VFXEvent:Fire("BL", target)
        VFXEvent:Fire("H", target)
        task.delay(ATTACK_ATTR_TIMEOUT, endAttackingState)
    end

    local function getAuraContainer()
        if auraContainer and auraContainer.Parent then
            return auraContainer
        end
        auraContainer = workspace:FindFirstChild("IgnoreRaycast") or workspace
        return auraContainer
    end

    local function findTargetFromPart(part)
        local current = part
        while current do
            if current == Character then
                return nil
            end
            if current:IsA("BasePart") and TARGET_PART_NAMES[current.Name] and current.Parent then
                local owner = current.Parent
                if owner ~= Character and owner:GetAttribute("Team") then
                    return owner
                end
            end
            if current:IsA("Model") and current:GetAttribute("Team") then
                return current
            end
            current = current.Parent
        end
        return nil
    end

    local function auraSweep()
        if not canAttack() then
            return
        end
        local container = getAuraContainer()
        local hitbox = ClientHitbox:Clone()
        local forwardOffset = CFrame.new(0, 0, -(hitbox.Size.Z / 2) + 2)
        hitbox.Size = Vector3.new(AURA_RANGE, hitbox.Size.Y, AURA_RANGE)
        hitbox.CFrame = HumanoidRootPart.CFrame * forwardOffset
        hitbox.Parent = container
        Debris:AddItem(hitbox, 0.15)
        local hits = workspace:GetPartsInPart(hitbox)
        if not hits then
            return
        end
        local processed = {}
        local myTeam = Character:GetAttribute("Team")
        for _, part in ipairs(hits) do
            if Character and not part:IsDescendantOf(Character) then
                local target = findTargetFromPart(part)
                if target and not processed[target] then
                    processed[target] = true
                    if not target:GetAttribute("IsImmune") and not target:GetAttribute("IsDied") then
                        local targetTeam = target:GetAttribute("Team")
                        if myTeam and targetTeam and myTeam ~= targetTeam then
                            local humanoid = target:FindFirstChildOfClass("Humanoid")
                            if humanoid and humanoid.Health > 0 then
                                attackTarget(target)
                            end
                        end
                    end
                end
            end
        end
    end

    local function toggleAura(state)
        if auraEnabled == state then
            return
        end
        auraEnabled = state
        if auraEnabled then
            -- fireWeaponEquip()
            nextPulseTime = 0
            heartbeatConnection = RunService.Heartbeat:Connect(function()
                local now = os.clock()
                if nextPulseTime <= now then
                    nextPulseTime = now + AURA_INTERVAL
                    auraSweep()
                end
            end)
        elseif heartbeatConnection then
            heartbeatConnection:Disconnect()
            heartbeatConnection = nil
        end
        print(string.format("[AuraKill] %s", auraEnabled and "enabled" or "disabled"))
    end

    local autoAuraTaskId = 0

    local function scheduleAutoAuraEnable()
        autoAuraTaskId += 1
        local thisTaskId = autoAuraTaskId

        task.spawn(function()
            if not game:IsLoaded() then
                game.Loaded:Wait()
            end

            local currentCharacter = Character
            if not currentCharacter then
                local ok, char = pcall(function()
                    return LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
                end)
                if ok then
                    currentCharacter = char
                end
            end

            if not currentCharacter then
                return
            end

            local humanoid = currentCharacter:FindFirstChildOfClass("Humanoid") or currentCharacter:WaitForChild("Humanoid", 5)
            local hrp = currentCharacter:FindFirstChild("HumanoidRootPart") or currentCharacter:WaitForChild("HumanoidRootPart", 5)
            if not humanoid or not hrp then
                return
            end

            task.wait(4)

            if thisTaskId ~= autoAuraTaskId then
                return
            end

            toggleAura(true)
        end)
    end

    if game.PlaceId == ARENA_PLACE_ID then
        scheduleAutoAuraEnable()
        LocalPlayer.CharacterAdded:Connect(function()
            scheduleAutoAuraEnable()
        end)
    else
        print("[AuraKill] Lobby detected; auto aura/equip skipped.")
    end

    _G.AutoMedalForceWeaponEquip = fireWeaponEquip
    _G.AutoMedalForceAuraEnable = function()
        toggleAura(true)
    end

end

waitForPlayerReady()
startAlmostAura()
startAutoPrivateLobby()
