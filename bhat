-- Bundles the auto-private-lobby helper with the almost-aura helper so both systems can run from a single script.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Debris = game:GetService("Debris")
local TeleportService = game:GetService("TeleportService")

local DEFAULT_LOBBY_PLACE_ID = 80620565999570
local ARENA_PLACE_ID = 136994634055993
local TELEPORT_PLACE_ID = DEFAULT_LOBBY_PLACE_ID
local TELEPORT_LINK_SOURCE_URL = "https://raw.githubusercontent.com/akuntbrox/special-dollop/refs/heads/main/jobId"
local AUTO_TELEPORT_JOB_ID = ""

if not game:IsLoaded() then
    game.Loaded:Wait()
end

local LocalPlayer = Players.LocalPlayer or Players.PlayerAdded:Wait()

local playerReady = false

local function waitForPlayerReady()
    if playerReady then
        return
    end

    local character = LocalPlayer.Character
    if not character or not character.Parent then
        local ok, result = pcall(function()
            return LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        end)
        if ok then
            character = result
        end
    end

    if character then
        pcall(function()
            character:WaitForChild("Humanoid", 10)
        end)
        pcall(function()
            character:WaitForChild("HumanoidRootPart", 10)
        end)
    end

    local playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
    if not playerGui then
        local ok, result = pcall(function()
            return LocalPlayer:WaitForChild("PlayerGui", 10)
        end)
        if ok then
            playerGui = result
        end
    end

    if playerGui then
        pcall(function()
            playerGui:WaitForChild("ScreenInfo", 10)
        end)

        local hotbar = playerGui:FindFirstChild("HotBar")
        if not hotbar then
            local ok, result = pcall(function()
                return playerGui:WaitForChild("HotBar", 10)
            end)
            if ok then
                hotbar = result
            end
        end

        if hotbar then
            local infoFrame = hotbar:FindFirstChild("Info")
            if not infoFrame then
                local ok, result = pcall(function()
                    return hotbar:WaitForChild("Info", 10)
                end)
                if ok then
                    infoFrame = result
                end
            end

            if infoFrame and infoFrame:IsA("GuiObject") then
                if not infoFrame.Visible then
                    local startTime = os.clock()
                    while not infoFrame.Visible and os.clock() - startTime < 60 do
                        local ok = pcall(function()
                            infoFrame:GetPropertyChangedSignal("Visible"):Wait()
                        end)
                        if not ok then
                            break
                        end
                    end
                end

                if not infoFrame.Visible then
                    warn("[AutoPrivateLobby] HotBar.Info never became visible; continuing anyway.")
                end
            end
        end
    end

    playerReady = true
end

local function parseTeleportLink(raw)
    if typeof(raw) ~= "string" then
        return nil, nil
    end

    local placeId = raw:match("placeId=(%d+)")
    if not placeId then
        placeId = raw:match("placeid=(%d+)")
    end

    local jobId = raw:match("gameInstanceId=([%w%-]+)")
    if not jobId then
        jobId = raw:match("jobId=([%w%-]+)") or raw:match("instanceId=([%w%-]+)")
    end

    return tonumber(placeId), jobId
end

local function fetchRemoteTeleportTarget()
    if TELEPORT_LINK_SOURCE_URL == "" then
        return nil, nil
    end

    local ok, response = pcall(function()
        return game:HttpGet(TELEPORT_LINK_SOURCE_URL)
    end)

    if not ok then
        warn(string.format("[AutoPrivateLobby] Failed to fetch teleport link: %s", tostring(response)))
        return nil, nil
    end

    local placeId, jobId = parseTeleportLink(response)
    if not jobId or jobId == "" then
        warn(string.format("[AutoPrivateLobby] Teleport link missing JobId: %s", tostring(response)))
        return nil, nil
    end

    return placeId, jobId
end

local function sanitizeJobId(jobId)
    if typeof(jobId) ~= "string" then
        jobId = tostring(jobId or "")
    end

    jobId = jobId:gsub("%s+", "")
    if jobId == "" then
        return nil
    end

    return jobId
end

local function teleportToJobId(jobId, contextLabel, overridePlaceId)
    local targetPlaceId = overridePlaceId or TELEPORT_PLACE_ID or game.PlaceId
    if typeof(targetPlaceId) ~= "number" then
        targetPlaceId = tonumber(targetPlaceId) or DEFAULT_LOBBY_PLACE_ID
    end

    local trimmed = sanitizeJobId(jobId)
    if not trimmed then
        local remotePlaceId, remoteJobId = fetchRemoteTeleportTarget()
        trimmed = sanitizeJobId(remoteJobId) or sanitizeJobId(AUTO_TELEPORT_JOB_ID)
        if remotePlaceId then
            targetPlaceId = remotePlaceId
        end
    end

    if not trimmed then
        warn(string.format("[AutoPrivateLobby] No JobId available%s; teleport aborted.", contextLabel and (" (" .. contextLabel .. ")") or ""))
        return false
    end

    local currentJobId = sanitizeJobId(game.JobId)
    if currentJobId and currentJobId == trimmed then
        print("[AutoPrivateLobby] Current server already matches teleport target; skipping teleport.")
        return false
    end

    local ok, err = pcall(function()
        TeleportService:TeleportToPlaceInstance(targetPlaceId, trimmed, LocalPlayer)
    end)

    if not ok then
        warn(string.format("[AutoPrivateLobby] Teleport failed%s: %s", contextLabel and (" (" .. contextLabel .. ")") or "", tostring(err)))
        return false
    end

    print(string.format("[AutoPrivateLobby] Teleporting to JobId %s (Place %s)", trimmed, tostring(targetPlaceId)))
    return true
end

_G = _G or {}
_G.AutoMedalTeleportToJobId = teleportToJobId

do
    local autoJob = sanitizeJobId(AUTO_TELEPORT_JOB_ID)
    if game.PlaceId == ARENA_PLACE_ID then
        print("[AutoPrivateLobby] Arena place detected at startup; skipping auto lobby teleport.")
    elseif autoJob or TELEPORT_LINK_SOURCE_URL ~= "" then
        teleportToJobId(autoJob, "AutoStart")
    end
end

local function bootstrapArenaModule()
    if game.PlaceId ~= DEFAULT_LOBBY_PLACE_ID then
        return
    end

    task.spawn(function()
        local deadline = os.clock() + 45
        while os.clock() < deadline do
            local playerScripts = LocalPlayer:FindFirstChild("PlayerScripts")
            local uiController = playerScripts and playerScripts:FindFirstChild("UIController")
            local uiInteractionController = uiController and uiController:FindFirstChild("UIInteractionZoneController")
            local arenaModuleScript = uiInteractionController and uiInteractionController:FindFirstChild("ArenaZone")
            if arenaModuleScript then
                local okModule, moduleOrError = pcall(function()
                    return require(arenaModuleScript)
                end)
                if okModule and type(moduleOrError) == "table" and type(moduleOrError.Init) == "function" then
                    local okInit, err = pcall(function()
                        moduleOrError.Init()
                    end)
                    if not okInit then
                        warn(string.format("[AutoPrivateLobby] ArenaZone.Init failed: %s", tostring(err)))
                    end
                end
                return
            end
            task.wait(1)
        end
    end)
end

bootstrapArenaModule()

local function startAutoPrivateLobby()
    local LOBBY_PLACE_ID = DEFAULT_LOBBY_PLACE_ID
    local TELEPORT_POSITION = Vector3.new(-224, 15, -798)
    local MATCH_TELEPORT_POINTS = {
        Vector3.new(-224, 15, -882);
        Vector3.new(-222, 15, -971);
    }
    local MATCH_TELEPORT_DELAY = 1
    local AUTO_START_AFTER_INVITES = true
    local USE_SAME_EQUIPMENT = false
    local TEAM_NAMES = {"Blue", "Red"}
    local SWAP_TEAM_ENABLED = false
    local SETTINGS_SEQUENCE = {"Private", "Map"}
    local TARGET_PLAYER_NAMES = {"nnunotuna561"}
    local busyMakingLobby = false
    local currentTeamName

    local function getHRP()
        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        return character:WaitForChild("HumanoidRootPart")
    end

    local function playTeleportEffect(hrp, position)
        local humanoid = hrp.Parent and hrp.Parent:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.Jump = true
            task.wait(0.05)
        end
        hrp.CFrame = CFrame.new(position)
    end

    local function teleportSequence()
        local ok, err = pcall(function()
            local hrp = getHRP()
            local points = #MATCH_TELEPORT_POINTS > 0 and MATCH_TELEPORT_POINTS or {TELEPORT_POSITION}
            for index, teleportPosition in ipairs(points) do
                playTeleportEffect(hrp, teleportPosition)
                if index < #points then
                    task.wait(MATCH_TELEPORT_DELAY)
                end
            end
        end)

        if not ok then
            warn(string.format("[AutoPrivateLobby] Failed to run teleport sequence: %s", tostring(err)))
        end
    end

    local function ensureLobbyJobConsistency()
        local remotePlaceId, remoteJobId = fetchRemoteTeleportTarget()
        local targetJobId = sanitizeJobId(remoteJobId)
        local currentJobId = sanitizeJobId(game.JobId)

        if targetJobId and currentJobId and targetJobId ~= currentJobId then
            local teleported = teleportToJobId(targetJobId, "LobbyJobMismatch", remotePlaceId)
            if not teleported then
                warn("[AutoPrivateLobby] Lobby job mismatch detected but teleport could not be triggered.")
            end
            return false
        end

        return true
    end

    local function runNonLobbyFlow()
        task.spawn(function()
            if not game:IsLoaded() then
                game.Loaded:Wait()
            end

            local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            if not character then
                return
            end

            local okHumanoid, humanoid = pcall(function()
                return character:WaitForChild("Humanoid", 5)
            end)
            local okHrp, hrp = pcall(function()
                return character:WaitForChild("HumanoidRootPart", 5)
            end)
            if not okHumanoid or not humanoid or not okHrp or not hrp then
                return
            end

            task.wait(4)

            local equipHandler = _G.AutoMedalForceWeaponEquip
            if equipHandler then
                local okEquip, errEquip = pcall(equipHandler)
                if not okEquip then
                    warn(string.format("[AutoPrivateLobby] Failed to trigger arena equip handler: %s", tostring(errEquip)))
                end
            else
                local events = ReplicatedStorage:WaitForChild("Events")
                local fallbackWeaponsEvent = events:WaitForChild("WeaponsEvent")
                local ok, err = pcall(function()
                    fallbackWeaponsEvent:FireServer("Equip/UnEquip")
                end)
                if not ok then
                    warn(string.format("[AutoPrivateLobby] Failed to trigger fallback equip: %s", tostring(err)))
                end
            end

            local auraHandler = _G.AutoMedalForceAuraEnable
            if auraHandler then
                auraHandler()
            end

            teleportSequence()

            local okReturn, errReturn = pcall(function()
                local playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui") or LocalPlayer:WaitForChild("PlayerGui", 5)
                if not playerGui then
                    return
                end
                local screenInfo = playerGui:FindFirstChild("ScreenInfo") or playerGui:WaitForChild("ScreenInfo", 5)
                if not screenInfo then
                    return
                end
                local arenaResultGui = screenInfo:FindFirstChild("ArenaResultTEST") or screenInfo:WaitForChild("ArenaResultTEST", 5)
                if not arenaResultGui then
                    return
                end

                local function waitForVisibility(targetState, timeout)
                    local deadline = os.clock() + timeout
                    while os.clock() < deadline do
                        if arenaResultGui.Visible == targetState then
                            return true
                        end
                        task.wait(0.25)
                    end
                    return false
                end

                if arenaResultGui.Visible then
                    local cleared = waitForVisibility(false, 60)
                    if not cleared then
                        warn("[AutoPrivateLobby] Arena result UI never hid; skipping auto return.")
                        return
                    end
                end

                local shown = waitForVisibility(true, 180)
                if not shown then
                    warn("[AutoPrivateLobby] Arena result UI never appeared; skipping auto return.")
                    return
                end

                task.wait(2)
                local events = ReplicatedStorage:WaitForChild("Events")
                local returnEvent = events:FindFirstChild("ArenaReturnToLobby") or events:WaitForChild("ArenaReturnToLobby")
                returnEvent:FireServer()
                print("[AutoPrivateLobby] Arena result detected; returning to lobby.")
            end)

            if not okReturn then
                warn(string.format("[AutoPrivateLobby] Failed to trigger ArenaReturnToLobby after arena sequence: %s", tostring(errReturn)))
            end
        end)

        warn(string.format("[AutoPrivateLobby] Non-lobby place detected (%s). Combat prep flow triggered.", tostring(game.PlaceId)))
    end
    task.wait(20)
    if game.PlaceId == ARENA_PLACE_ID then
        runNonLobbyFlow()
        return
    end

    if game.PlaceId ~= LOBBY_PLACE_ID then
        warn(string.format("[AutoPrivateLobby] Unexpected place (%s); redirecting to configured job.", tostring(game.PlaceId)))
        teleportToJobId(nil, "NonArenaRedirect")
        return
    end
    if not ensureLobbyJobConsistency() then
        return
    end

    local eventsFolder = ReplicatedStorage:WaitForChild("Events")
    local createGroupEvent = eventsFolder:WaitForChild("CreateArenaGroup")
    local changeSettingEvent = eventsFolder:WaitForChild("ArenaGroupChangeSetting")
    local inviteEvent = eventsFolder:WaitForChild("SendInvitePlayerToArenaGroup")
    local swapTeamEvent = eventsFolder:WaitForChild("SwapArenaTeam")
    local startArenaEvent = eventsFolder:WaitForChild("StartArenaGroup")
    local playerGui = LocalPlayer:WaitForChild("PlayerGui")

    local function getArenaGroupContainer()
        local gui = LocalPlayer:FindFirstChildOfClass("PlayerGui") or LocalPlayer:WaitForChild("PlayerGui", 5)
        if not gui then
            return nil
        end

        local interactionZones = gui:FindFirstChild("InteractionZones")
        if not interactionZones then
            return nil
        end

        local arenaGroup = interactionZones:FindFirstChild("ArenaGroup")
        if not arenaGroup then
            return nil
        end

        return arenaGroup:FindFirstChild("Group")
    end

    local function detectCurrentTeam()
        local groupFolder = getArenaGroupContainer()
        if not groupFolder then
            return nil
        end

        for _, teamName in ipairs(TEAM_NAMES) do
            local teamFrame = groupFolder:FindFirstChild(teamName)
            if teamFrame then
                local found = teamFrame:FindFirstChild(LocalPlayer.Name, true)
                if found then
                    return teamName
                end
            end
        end

        return nil
    end

    local function getTeamMembers(teamName)
        local groupFolder = getArenaGroupContainer()
        if not groupFolder then
            return nil
        end

        local teamFrame = groupFolder:FindFirstChild(teamName)
        if not teamFrame then
            return nil
        end

        local added = {}
        local members = {}

        for _, desc in ipairs(teamFrame:GetDescendants()) do
            local teammate = Players:FindFirstChild(desc.Name)
            if teammate and not added[teammate] then
                table.insert(members, teammate)
                added[teammate] = true
            end
        end

        return members
    end

    local function swapPlayerToOppositeTeam(targetPlayer)
        if not targetPlayer or targetPlayer == LocalPlayer then
            return
        end

        local ok, err = pcall(function()
            swapTeamEvent:FireServer(targetPlayer.UserId)
        end)

        if not ok then
            warn(string.format("[AutoPrivateLobby] Failed to swap %s: %s", targetPlayer.Name, tostring(err)))
        end
    end

    local function ensureSoloTeam()
        if not currentTeamName or not SWAP_TEAM_ENABLED then
            return
        end

        local teammates = getTeamMembers(currentTeamName)
        if not teammates then
            return
        end

        for _, teammate in ipairs(teammates) do
            if teammate ~= LocalPlayer then
                swapPlayerToOppositeTeam(teammate)
                task.wait(0.1)
            end
        end
    end

    local function updateTeamIfNeeded()
        local detectedTeam = detectCurrentTeam()
        if detectedTeam and detectedTeam ~= currentTeamName then
            currentTeamName = detectedTeam
            print(string.format("[AutoPrivateLobby] Detected team: %s", currentTeamName))
            ensureSoloTeam()
        elseif detectedTeam and detectedTeam == currentTeamName then
            ensureSoloTeam()
        end
    end

    task.spawn(function()
        while true do
            updateTeamIfNeeded()
            task.wait(1)
        end
    end)

    playerGui.ChildAdded:Connect(function(child)
        if child.Name == "InteractionZones" then
            updateTeamIfNeeded()
        end
    end)

    playerGui.DescendantAdded:Connect(function(descendant)
        if descendant.Name == LocalPlayer.Name then
            updateTeamIfNeeded()
        end
    end)

    local function startArenaAfterInvites()
        if not AUTO_START_AFTER_INVITES then
            return
        end

        local ok, err = pcall(function()
            startArenaEvent:FireServer(USE_SAME_EQUIPMENT)
        end)

        if not ok then
            warn(string.format("[AutoPrivateLobby] Failed to start arena automatically: %s", tostring(err)))
        else
            print("[AutoPrivateLobby] Auto-started arena after inviting players.")
        end
    end

    local function invitePlayers()
        for _, targetName in ipairs(TARGET_PLAYER_NAMES) do
            local targetPlayer = Players:FindFirstChild(targetName)
            if not targetPlayer then
                local ok, found = pcall(function()
                    return Players:WaitForChild(targetName, 5)
                end)
                if ok then
                    targetPlayer = found
                end
            end

            if not targetPlayer then
                warn(string.format("[AutoPrivateLobby] Could not find player '%s' to invite.", targetName))
            else
                local ok, err = pcall(function()
                    inviteEvent:InvokeServer(targetPlayer)
                end)

                if not ok then
                    warn(string.format("[AutoPrivateLobby] Failed to invite %s: %s", targetPlayer.Name, tostring(err)))
                end
                task.wait(0.5)
            end
        end

        task.wait(2.5)
        startArenaAfterInvites()
    end

    local function makeLobbyPrivate()
        if busyMakingLobby then
            return
        end

        busyMakingLobby = true

        local ok, err = pcall(function()
            createGroupEvent:FireServer()
            task.wait(0.5)

            for _, setting in ipairs(SETTINGS_SEQUENCE) do
                changeSettingEvent:FireServer(setting)
                task.wait(0.4)
            end

            invitePlayers()
        end)

        if not ok then
            warn("[AutoPrivateLobby] Failed to apply settings:", err)
        end

        busyMakingLobby = false
    end

    makeLobbyPrivate()

    LocalPlayer.CharacterAdded:Connect(function()
        task.wait(1)
        makeLobbyPrivate()
    end)
end

local function startAlmostAura()
    local Events = ReplicatedStorage:WaitForChild("Events")
    local ModelsFolder = ReplicatedStorage:WaitForChild("Models")
    local ClientHitbox = ModelsFolder:WaitForChild("ClientAroundHitbox")
    local WeaponsEvent = Events:WaitForChild("WeaponsEvent")

    local function fireWeaponEquip()
        local ok, err = pcall(function()
            local args = {"Equip/UnEquip"}
            WeaponsEvent:FireServer(table.unpack(args))
        end)
        if not ok then
            warn(string.format("[AuraKill] Failed to prep weapon equip: %s", tostring(err)))
        end
        return ok
    end

    local AURA_RANGE = 150
    local AURA_INTERVAL = 0.02
    local MAX_COMBO_STAGE = 3
    local ATTACK_ATTR_TIMEOUT = 0.15

    local auraEnabled = false
    local comboStage = 0
    local nextPulseTime = 0
    local heartbeatConnection = nil

    local Character = nil
    local HumanoidRootPart = nil
    local auraContainer = nil
    local DEFAULT_DIRECTION = "0:0:-1"
    local attackingStateCount = 0
    local TARGET_PART_NAMES = {
        CharHitbox = true;
        CharHitBox = true;
    }

    local DEFAULT_WALK_SPEED = 16
    local BOOST_WALK_SPEED = 45
    local BaseWalkSpeed = DEFAULT_WALK_SPEED
    local StoredWalkSpeed = nil
    local WalkSpeedConnection = nil
    local suppressWalkSpeedEvent = false
    local speedBoostEnabled = true

    local function applyWalkSpeedState()
        local humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
        if not humanoid then
            return
        end
        if speedBoostEnabled then
            if StoredWalkSpeed == nil then
                StoredWalkSpeed = humanoid.WalkSpeed ~= 0 and humanoid.WalkSpeed or BaseWalkSpeed
            end
            if humanoid.WalkSpeed ~= BOOST_WALK_SPEED then
                suppressWalkSpeedEvent = true
                humanoid.WalkSpeed = BOOST_WALK_SPEED
                suppressWalkSpeedEvent = false
            end
        else
            local target = StoredWalkSpeed or BaseWalkSpeed or DEFAULT_WALK_SPEED
            StoredWalkSpeed = nil
            if humanoid.WalkSpeed ~= target then
                suppressWalkSpeedEvent = true
                humanoid.WalkSpeed = target
                suppressWalkSpeedEvent = false
            end
            BaseWalkSpeed = humanoid.WalkSpeed
        end
    end

    local function bindHumanoidSpeed(humanoid)
        if WalkSpeedConnection then
            WalkSpeedConnection:Disconnect()
            WalkSpeedConnection = nil
        end
        if not humanoid then
            return
        end
        BaseWalkSpeed = humanoid.WalkSpeed or DEFAULT_WALK_SPEED
        WalkSpeedConnection = humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
            if suppressWalkSpeedEvent then
                return
            end
            if speedBoostEnabled then
                if humanoid.WalkSpeed ~= BOOST_WALK_SPEED then
                    suppressWalkSpeedEvent = true
                    humanoid.WalkSpeed = BOOST_WALK_SPEED
                    suppressWalkSpeedEvent = false
                end
            else
                BaseWalkSpeed = humanoid.WalkSpeed
            end
        end)
    end

    local function setCharacter(char)
        Character = char
        HumanoidRootPart = nil
        attackingStateCount = 0
        if not Character then
            return
        end
        task.spawn(function()
            HumanoidRootPart = Character:WaitForChild("HumanoidRootPart", 5)
            local humanoid = HumanoidRootPart and HumanoidRootPart.Parent and HumanoidRootPart.Parent:FindFirstChildOfClass("Humanoid")
            bindHumanoidSpeed(humanoid)
            applyWalkSpeedState()
        end)
    end

    if LocalPlayer.Character then
        setCharacter(LocalPlayer.Character)
    end
    LocalPlayer.CharacterAdded:Connect(setCharacter)

    local function canAttack()
        if not Character or not Character.Parent then
            return false
        end
        if Character:GetAttribute("Stunned") then
            return false
        end
        if not Character:GetAttribute("IsEquipped") then
            return false
        end
        if Character:GetAttribute("IsDashing") or Character:GetAttribute("IsEquipping") or Character:GetAttribute("IsCrawling") then
            return false
        end
        if not HumanoidRootPart or not HumanoidRootPart.Parent then
            return false
        end
        return true
    end

    local function buildPayload(target)
        local id = target:GetAttribute("ID")
        if id then
            return {id}
        end
        return target
    end

    local function beginAttackingState()
        if not Character then
            return
        end
        attackingStateCount = attackingStateCount + 1
        Character:SetAttribute("Attacking", true)
    end

    local function endAttackingState()
        if not Character then
            attackingStateCount = 0
            return
        end
        if attackingStateCount > 0 then
            attackingStateCount = attackingStateCount - 1
        end
        if attackingStateCount <= 0 then
            attackingStateCount = 0
            Character:SetAttribute("Attacking", false)
        end
    end

    local function compressVector(vec)
        return string.format("%.2f:%.2f:%.2f", vec.X, vec.Y, vec.Z)
    end

    local PRIORITY_TARGET_PARTS = {"HumanoidRootPart", "CharHitbox", "CharHitBox"}

    local function getTargetPosition(target)
        if not target then
            return nil
        end
        if target:IsA("BasePart") then
            return target.Position
        end
        for _, partName in ipairs(PRIORITY_TARGET_PARTS) do
            local part = target:FindFirstChild(partName, true)
            if part and part:IsA("BasePart") then
                return part.Position
            end
        end
        local primary = target.PrimaryPart
        if primary then
            return primary.Position
        end
        if target:IsA("Model") then
            local success, pivot = pcall(function()
                return target:GetPivot()
            end)
            if success and pivot then
                return pivot.Position
            end
            local anyPart = target:FindFirstChildWhichIsA("BasePart", true)
            if anyPart then
                return anyPart.Position
            end
        end
        return nil
    end

    local function nextComboStage()
        comboStage = comboStage + 1
        if comboStage > MAX_COMBO_STAGE then
            comboStage = 1
        end
        return comboStage
    end

    local function getDirectionString(target)
        local base = nil
        if HumanoidRootPart then
            base = HumanoidRootPart.CFrame.LookVector
            if target then
                local targetPosition = getTargetPosition(target)
                if targetPosition then
                    local offset = targetPosition - HumanoidRootPart.Position
                    if offset.Magnitude > 0.01 then
                        base = offset.Unit
                    end
                end
            end
        end
        if not base then
            return DEFAULT_DIRECTION
        end
        return compressVector(base)
    end

    local function attackTarget(target)
        local stage = nextComboStage()
        local payload = buildPayload(target)
        local directionString = getDirectionString(target)
        beginAttackingState()
        Events.AttackV2:FireServer(1, stage)
        local directionArgs = {4, stage}
        directionArgs[4] = directionString
        Events.AttackV2:FireServer(table.unpack(directionArgs))
        Events.AttackV2:FireServer(5, stage, payload)
        if Character and Character:GetAttribute("Subclass") == "Assassin" and stage == MAX_COMBO_STAGE then
            Events.AttackV2:FireServer(5, stage, payload)
        end
        Events.AttackV2:FireServer(3, stage)
        Events.VFX_Client:Fire("BL", target)
        Events.VFX_Client:Fire("H", target)
        task.delay(ATTACK_ATTR_TIMEOUT, endAttackingState)
    end

    local function getAuraContainer()
        if auraContainer and auraContainer.Parent then
            return auraContainer
        end
        auraContainer = workspace:FindFirstChild("IgnoreRaycast") or workspace
        return auraContainer
    end

    local function findTargetFromPart(part)
        local current = part
        while current do
            if current == Character then
                return nil
            end
            if current:IsA("BasePart") and TARGET_PART_NAMES[current.Name] and current.Parent then
                local owner = current.Parent
                if owner ~= Character and owner:GetAttribute("Team") then
                    return owner
                end
            end
            if current:IsA("Model") and current:GetAttribute("Team") then
                return current
            end
            current = current.Parent
        end
        return nil
    end

    local function auraSweep()
        if not canAttack() then
            return
        end
        local container = getAuraContainer()
        local hitbox = ClientHitbox:Clone()
        local forwardOffset = CFrame.new(0, 0, -(hitbox.Size.Z / 2) + 2)
        hitbox.Size = Vector3.new(AURA_RANGE, hitbox.Size.Y, AURA_RANGE)
        hitbox.CFrame = HumanoidRootPart.CFrame * forwardOffset
        hitbox.Parent = container
        Debris:AddItem(hitbox, 0.15)
        local hits = workspace:GetPartsInPart(hitbox)
        if not hits then
            return
        end
        local processed = {}
        local myTeam = Character:GetAttribute("Team")
        for _, part in ipairs(hits) do
            if Character and not part:IsDescendantOf(Character) then
                local target = findTargetFromPart(part)
                if target and not processed[target] then
                    processed[target] = true
                    if not target:GetAttribute("IsImmune") and not target:GetAttribute("IsDied") then
                        local targetTeam = target:GetAttribute("Team")
                        if myTeam and targetTeam and myTeam ~= targetTeam then
                            local humanoid = target:FindFirstChildOfClass("Humanoid")
                            if humanoid and humanoid.Health > 0 then
                                attackTarget(target)
                            end
                        end
                    end
                end
            end
        end
    end

    local function toggleAura(state)
        if auraEnabled == state then
            if auraEnabled and game.PlaceId ~= DEFAULT_LOBBY_PLACE_ID then
                fireWeaponEquip()
            end
            return
        end
        auraEnabled = state
        applyWalkSpeedState()
        if auraEnabled then
            if game.PlaceId ~= DEFAULT_LOBBY_PLACE_ID then
                fireWeaponEquip()
            end
            nextPulseTime = 0
            heartbeatConnection = RunService.Heartbeat:Connect(function()
                local now = os.clock()
                if nextPulseTime <= now then
                    nextPulseTime = now + AURA_INTERVAL
                    auraSweep()
                end
            end)
        elseif heartbeatConnection then
            heartbeatConnection:Disconnect()
            heartbeatConnection = nil
        end
        print(string.format("[AuraKill] %s", auraEnabled and "enabled" or "disabled"))
    end

    local function toggleSpeedBoost(state)
        if state == nil then
            state = not speedBoostEnabled
        end
        if speedBoostEnabled == state then
            return
        end
        speedBoostEnabled = state
        applyWalkSpeedState()
        print(string.format("[AuraKill] Walk speed boost %s", speedBoostEnabled and "enabled" or "disabled"))
    end

    local autoAuraTaskId = 0

    local function scheduleAutoAuraEnable()
        autoAuraTaskId += 1
        local thisTaskId = autoAuraTaskId

        task.spawn(function()
            if not game:IsLoaded() then
                game.Loaded:Wait()
            end

            local currentCharacter = Character
            if not currentCharacter then
                local ok, char = pcall(function()
                    return LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
                end)
                if ok then
                    currentCharacter = char
                end
            end

            if not currentCharacter then
                return
            end

            local humanoid = currentCharacter:FindFirstChildOfClass("Humanoid") or currentCharacter:WaitForChild("Humanoid", 5)
            local hrp = currentCharacter:FindFirstChild("HumanoidRootPart") or currentCharacter:WaitForChild("HumanoidRootPart", 5)
            if not humanoid or not hrp then
                return
            end

            task.wait(4)

            if thisTaskId ~= autoAuraTaskId then
                return
            end

            toggleAura(true)
        end)
    end

    scheduleAutoAuraEnable()
    LocalPlayer.CharacterAdded:Connect(function()
        scheduleAutoAuraEnable()
    end)

    _G.AutoMedalForceWeaponEquip = fireWeaponEquip
    _G.AutoMedalForceAuraEnable = function()
        toggleAura(true)
    end

end

waitForPlayerReady()
startAlmostAura()
startAutoPrivateLobby()
