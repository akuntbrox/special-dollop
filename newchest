local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local resultInviteEvent = ReplicatedStorage:WaitForChild("Events"):WaitForChild("ResultInviteArenaGroup")

local ACCEPT_ARGS = {true, false}
local DECLINE_ARGS = {false, true}

local TARGET_DISPLAY_NAMES = {
    "JajangShotgun",
}

local ACCEPT_COOLDOWN = 1.25
local DECLINE_COOLDOWN = 0.85
local PATH_TIMEOUT = 4
local DECLINE_NON_TARGETS = true
local LABEL_PATH = {"ScreenInfo", "Invites", "DungeonInvite", "Bar", "Info", "Label"}
local INVITE_FRAME_PATH = {"ScreenInfo", "Invites", "DungeonInvite"}
local LOG_PREFIX = "[DL-AutoInvite]"
local SERVER_HOP_DELAY = 1.5
local SERVER_LIST_PAGE_LIMIT = 5
local ENABLE_SERVER_HOP = true

local function formatMessage(message, ...)
    local ok, formatted = pcall(string.format, message, ...)
    if ok then
        return string.format("%s %s", LOG_PREFIX, formatted)
    end
    return string.format("%s %s", LOG_PREFIX, tostring(message))
end

local function normalizeDisplayName(raw)
    if typeof(raw) ~= "string" then
        return ""
    end

    local withoutBrackets = raw:gsub("%[[^%]]*%]", "")
    local collapsed = withoutBrackets:gsub("%s+", "")
    if collapsed == "" then
        return ""
    end

    return string.lower(collapsed)
end

local normalizedTargets = {}
for _, name in ipairs(TARGET_DISPLAY_NAMES) do
    local normalized = normalizeDisplayName(name)
    if normalized ~= "" then
        normalizedTargets[normalized] = true
    end
end

local hasTargetsConfigured = next(normalizedTargets) ~= nil
local autoServerHopEnabled = ENABLE_SERVER_HOP and hasTargetsConfigured

if not hasTargetsConfigured then
    warn(formatMessage("No target display names configured; script will remain idle."))
elseif autoServerHopEnabled then
    print(formatMessage("Auto server hop enabled via flag."))
else
    print(formatMessage("Auto server hop disabled via flag."))
end

local function requestServerPage(cursor)
    local url = string.format(
        "https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Asc&limit=100",
        game.PlaceId
    )

    if cursor then
        url = string.format("%s&cursor=%s", url, HttpService:UrlEncode(cursor))
    end

    local ok, response = pcall(HttpService.GetAsync, HttpService, url)
    if not ok then
        warn(formatMessage("Failed to fetch server list: %s", tostring(response)))
        return nil, nil
    end

    local decodeOk, decoded = pcall(HttpService.JSONDecode, HttpService, response)
    if not decodeOk or typeof(decoded) ~= "table" then
        warn(formatMessage("Failed to decode server list response: %s", tostring(decoded)))
        return nil, nil
    end

    return decoded.data, decoded.nextPageCursor
end

local function selectServerId()
    local cursor

    for _ = 1, SERVER_LIST_PAGE_LIMIT do
        local data, nextCursor = requestServerPage(cursor)
        if not data then
            break
        end

        for _, server in ipairs(data) do
            if server and server.id and server.id ~= game.JobId then
                local playing = tonumber(server.playing)
                local maxPlayers = tonumber(server.maxPlayers)

                if playing and maxPlayers and playing < maxPlayers then
                    return server.id
                end
            end
        end

        if not nextCursor then
            break
        end

        cursor = nextCursor
    end

    return nil
end

local serverHopInProgress = false

local function scheduleServerHop(rawLabel)
    if not autoServerHopEnabled or serverHopInProgress then
        return
    end

    serverHopInProgress = true

    task.spawn(function()
        local descriptor = rawLabel and rawLabel ~= "" and rawLabel or "unknown"
        print(formatMessage("Auto server hop triggered (non-target invite from %s).", descriptor))
        task.wait(SERVER_HOP_DELAY)

        local serverId = selectServerId()
        if not serverId then
            warn(formatMessage("Auto server hop failed: no suitable server found."))
            serverHopInProgress = false
            return
        end

        local ok, err = pcall(function()
            TeleportService:TeleportToPlaceInstance(game.PlaceId, serverId)
        end)

        if not ok then
            warn(formatMessage("Teleport failed: %s", tostring(err)))
            serverHopInProgress = false
        end
    end)
end

local function safeWait(parent, childName, timeout)
    if not parent then
        return nil
    end

    local child = parent:FindFirstChild(childName)
    if child then
        return child
    end

    local ok, result = pcall(parent.WaitForChild, parent, childName, timeout or PATH_TIMEOUT)
    if ok then
        return result
    end

    return nil
end

local function getInstanceAtPath(root, path, timeout)
    local current = root
    for _, node in ipairs(path) do
        current = safeWait(current, node, timeout)
        if not current then
            return nil
        end
    end
    return current
end

local function getInviteFrame(timeout)
    return getInstanceAtPath(playerGui, INVITE_FRAME_PATH, timeout)
end

local function getInviteLabel(timeout)
    return getInstanceAtPath(playerGui, LABEL_PATH, timeout)
end

local function disconnect(conn)
    if conn then
        conn:Disconnect()
    end
end

local activeLabel
local inviteFrame
local labelTextConn
local labelAncestryConn
local inviteVisibleConn
local inviteAncestryConn
local labelSearching = false
local lastAcceptTimestamp = 0
local lastDeclineTimestamp = 0

local function fireInviteResult(accept)
    local ok, err = pcall(function()
        if accept then
            resultInviteEvent:FireServer(table.unpack(ACCEPT_ARGS))
        else
            resultInviteEvent:FireServer(table.unpack(DECLINE_ARGS))
        end
    end)

    if not ok then
        warn(formatMessage("Failed to %s invite: %s", accept and "accept" or "decline", tostring(err)))
        return false
    end

    return true
end

local function respondToInvite(accept, rawLabel)
    local now = os.clock()

    if accept then
        if now - lastAcceptTimestamp < ACCEPT_COOLDOWN then
            return false
        end
        if fireInviteResult(true) then
            lastAcceptTimestamp = now
            print(formatMessage("Accepted invite from %s", rawLabel ~= "" and rawLabel or "target player"))
            return true
        end
    else
        if now - lastDeclineTimestamp < DECLINE_COOLDOWN then
            return false
        end
        if fireInviteResult(false) then
            lastDeclineTimestamp = now
            if rawLabel and rawLabel ~= "" then
                print(formatMessage("Declined invite from %s", rawLabel))
            else
                print(formatMessage("Declined invite."))
            end
            return true
        end
    end

    return false
end

local function evaluateLabelText(rawText)
    if typeof(rawText) ~= "string" or rawText == "" then
        return
    end

    local normalized = normalizeDisplayName(rawText)
    if normalized == "" then
        return
    end

    if normalizedTargets[normalized] then
        respondToInvite(true, rawText)
    else
        if DECLINE_NON_TARGETS then
            respondToInvite(false, rawText)
        end
        scheduleServerHop(rawText)
    end
end

local function disconnectLabelConnections()
    disconnect(labelTextConn)
    disconnect(labelAncestryConn)
    labelTextConn = nil
    labelAncestryConn = nil
end

local function disconnectInviteConnections()
    disconnect(inviteVisibleConn)
    disconnect(inviteAncestryConn)
    inviteVisibleConn = nil
    inviteAncestryConn = nil
    inviteFrame = nil
end

local acquireLabel

local function connectInviteFrame(frame)
    if inviteFrame == frame and inviteVisibleConn then
        return
    end

    disconnectInviteConnections()
    inviteFrame = frame

    if not frame then
        return
    end

    inviteVisibleConn = frame:GetPropertyChangedSignal("Visible"):Connect(function()
        if frame.Visible and activeLabel then
            evaluateLabelText(activeLabel.Text)
        end
    end)

    inviteAncestryConn = frame.AncestryChanged:Connect(function(_, parent)
        if not parent then
            disconnectInviteConnections()
            activeLabel = nil
            labelSearching = false
            task.defer(acquireLabel)
        end
    end)
end

local function attachToLabel(label)
    if activeLabel == label then
        return
    end

    disconnectLabelConnections()
    activeLabel = label

    local frame = getInviteFrame(1) or label:FindFirstAncestor("DungeonInvite")
    connectInviteFrame(frame)
    evaluateLabelText(label.Text)

    labelTextConn = label:GetPropertyChangedSignal("Text"):Connect(function()
        evaluateLabelText(label.Text)
    end)

    labelAncestryConn = label.AncestryChanged:Connect(function(_, parent)
        if not parent then
            disconnectLabelConnections()
            disconnectInviteConnections()
            activeLabel = nil
            labelSearching = false
            task.defer(acquireLabel)
        end
    end)
end

acquireLabel = function()
    if labelSearching or activeLabel then
        return
    end

    labelSearching = true

    task.spawn(function()
        while not activeLabel do
            local label = getInviteLabel(PATH_TIMEOUT)
            if label then
                attachToLabel(label)
                break
            end
            task.wait(1.5)
        end

        labelSearching = false
    end)
end

acquireLabel()

playerGui.ChildAdded:Connect(function(child)
    if child.Name == "ScreenInfo" or child.Name == "Invites" then
        task.defer(acquireLabel)
    end
end)

player.CharacterAdded:Connect(function()
    task.wait(2)
    acquireLabel()
end)
